"use strict";(self.webpackChunkkrebit_apidocs=self.webpackChunkkrebit_apidocs||[]).push([[9854],{53593:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>s,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"getting-started/ai-prompts","title":"Quickstart: AI prompts","description":"Use ready-made prompts to work with the Krebit Sign API when collaborating with AI coding assistants.","source":"@site/docs/getting-started/ai-prompts.md","sourceDirName":"getting-started","slug":"/getting-started/ai-prompts","permalink":"/docs/getting-started/ai-prompts","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"Quickstart: AI prompts","description":"Use ready-made prompts to work with the Krebit Sign API when collaborating with AI coding assistants.","sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Authenticate with Krebit Sign","permalink":"/docs/getting-started/authentication"},"next":{"title":"Signings guide","permalink":"/docs/signings/"}}');var r=n(74848),o=n(28453);const a={title:"Quickstart: AI prompts",description:"Use ready-made prompts to work with the Krebit Sign API when collaborating with AI coding assistants.",sidebar_position:3},s="Quickstart: Using AI prompts with the Krebit Sign API",d={},l=[{value:"Prerequisites",id:"prerequisites",level:2},{value:"Set up your Krebit Sign account",id:"set-up-your-krebit-sign-account",level:2},{value:"Starter prompt",id:"starter-prompt",level:2},{value:"How to use the feature prompts",id:"how-to-use-the-feature-prompts",level:2},{value:"Feature prompts",id:"feature-prompts",level:2},{value:"Hosted OAuth and token refresh",id:"hosted-oauth-and-token-refresh",level:3},{value:"Implementation prompt",id:"implementation-prompt",level:4},{value:"Hardening prompt",id:"hardening-prompt",level:4},{value:"Create, populate, and send a signing package",id:"create-populate-and-send-a-signing-package",level:3},{value:"Implementation prompt",id:"implementation-prompt-1",level:4},{value:"Hardening prompt",id:"hardening-prompt-1",level:4},{value:"Track signing status and download files",id:"track-signing-status-and-download-files",level:3},{value:"Implementation prompt",id:"implementation-prompt-2",level:4},{value:"Hardening prompt",id:"hardening-prompt-2",level:4},{value:"Webhooks for signing lifecycle events",id:"webhooks-for-signing-lifecycle-events",level:3},{value:"Implementation prompt",id:"implementation-prompt-3",level:4},{value:"Hardening prompt",id:"hardening-prompt-3",level:4}];function c(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"quickstart-using-ai-prompts-with-the-krebit-sign-api",children:"Quickstart: Using AI prompts with the Krebit Sign API"})}),"\n",(0,r.jsx)(t.p,{children:"In this guide, you will find copy-paste prompts that help large language models (LLMs) produce accurate code for the Krebit Sign API. Use them inside AI-enabled IDEs (Cursor, GitHub Copilot, Zed, Windsurf, and similar tools) to bootstrap working integrations that follow Krebit's conventions and best practices."}),"\n",(0,r.jsx)(t.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,r.jsx)(t.p,{children:"For this guide, assume that you are prompting an LLM through an AI-focused IDE. If you are evaluating different tools, read the following references:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"https://docs.cursor.com/context/rules-for-ai",children:"Cursor"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"https://docs.github.com/en/enterprise-cloud@latest/copilot/customizing-copilot/adding-repository-custom-instructions-for-github-copilot",children:"GitHub Copilot"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"https://zed.dev/docs/assistant/prompting",children:"Zed"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"https://docs.codeium.com/chat/overview#persistent-context",children:"Windsurf"})}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"A basic understanding of the Krebit Sign API endpoints you want to call will make the prompts more effective."}),"\n",(0,r.jsx)(t.h2,{id:"set-up-your-krebit-sign-account",children:"Set up your Krebit Sign account"}),"\n",(0,r.jsx)(t.p,{children:"Do the following tasks before asking the LLM to generate code:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Create a Krebit organization"}),": Visit ",(0,r.jsx)(t.code,{children:"https://{organization}.krebit.se/developer/my-apps"})," (replace ",(0,r.jsx)(t.code,{children:"{organization}"})," with your tenant name) and register or sign in."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Register an OAuth application"}),": Create an app from the developer portal to obtain a ",(0,r.jsx)(t.code,{children:"client_id"})," and ",(0,r.jsx)(t.code,{children:"client_secret"}),". Store them as ",(0,r.jsx)(t.code,{children:"KREBIT_CLIENT_ID"})," and ",(0,r.jsx)(t.code,{children:"KREBIT_CLIENT_SECRET"})," in your environment."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Choose a redirect URI"}),": Define where Krebit should send users after they approve access. Save it as ",(0,r.jsx)(t.code,{children:"KREBIT_REDIRECT_URI"})," and add the same value to your app's callback settings."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Capture your base domain"}),": Save your tenant domain (for example, ",(0,r.jsx)(t.code,{children:"yourco.krebit.se"}),") as ",(0,r.jsx)(t.code,{children:"KREBIT_ORGANIZATION_DOMAIN"}),". The base API URL becomes ",(0,r.jsx)(t.code,{children:"https://$KREBIT_ORGANIZATION_DOMAIN"})," and all REST endpoints live under ",(0,r.jsx)(t.code,{children:"/api/1.0"}),"."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Protect your secrets"}),": Use a ",(0,r.jsx)(t.code,{children:".env"})," file or a secrets manager. Never hard-code credentials inside client-side or shared code snippets."]}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"With these pieces in place, you can guide an LLM to acquire tokens and call authenticated endpoints."}),"\n",(0,r.jsx)(t.h2,{id:"starter-prompt",children:"Starter prompt"}),"\n",(0,r.jsx)(t.p,{children:"Copy the following prompt into your LLM to establish the correct context before generating any Krebit Sign API code."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"You are an expert in building with the Krebit Sign API. Your goal is to help developers quickly build digital signing workflows for their SaaS applications. Use the following documentation and rules whenever you answer:\n\n## API surface\n- The Krebit Sign API base URL is `https://{organization}.krebit.se/api/1.0`. Replace `{organization}` with the tenant subdomain (for example, `yourco.krebit.se`).\n- Authentication uses the OAuth 2.0 Authorization Code flow. Users grant access through `https://{organization}.krebit.se/oauth/authorize`, and the backend exchanges the authorization code for tokens at `https://{organization}.krebit.se/oauth/token`.\n- Every API request must include `Authorization: Bearer <access_token>` and `Accept: application/json`. Use `Content-Type: application/json` for JSON payloads and `multipart/form-data` when uploading documents.\n\n## Environment setup\n1. Read `KREBIT_CLIENT_ID`, `KREBIT_CLIENT_SECRET`, `KREBIT_REDIRECT_URI`, and `KREBIT_ORGANIZATION_DOMAIN` from environment variables. Build `KREBIT_BASE_URL = https://$KREBIT_ORGANIZATION_DOMAIN` and append `/api/1.0` for REST endpoints.\n2. After exchanging the authorization code, store the returned `access_token` (and optional `refresh_token`) securely\u2014never commit them to source control. Reference them at runtime as `KREBIT_ACCESS_TOKEN`.\n3. Use HTTPS for every request. If you are running against a non-production tenant, still rely on TLS and valid redirect URIs.\n4. Only persist tokens or user-specific data in your database after encrypting at rest and limiting access.\n\n## Implementation steps\n1. **Implement OAuth**: Generate the authorization URL with the registered redirect URI and a CSRF-resistant `state` value. Handle the callback, verify `state`, and call `POST /oauth/token` with `grant_type=authorization_code` to obtain bearer tokens.\n2. **Create a reusable HTTP client**: Configure the client with the `Authorization` header and JSON defaults. Consider automatically refreshing tokens by calling `POST /oauth/token` with `grant_type=refresh_token`.\n3. **Call Krebit endpoints**: Show working examples that use `/api/1.0` routes\u2014`GET /api/1.0/me` to validate authentication, `POST /api/1.0/signings` to create drafts, `POST /api/1.0/signings/{uuid}/documents` to upload PDFs, `POST /api/1.0/signings/{uuid}/recipients` to add signers, and `POST /api/1.0/signings/{uuid}/send` to trigger delivery.\n4. **Handle responses**: Parse JSON payloads, inspect `request_id` fields when present, and surface useful status to the caller. Map HTTP status codes to actionable error messages.\n5. **Plan extensions**: Suggest how to read signing status, download completed documents, set up webhooks, or cancel a signing.\nAlways cite the relevant Krebit Sign docs or OpenAPI schema before proposing new code.\n\n## Best practices\n- Validate all input before calling Krebit endpoints. Enforce required fields (for example, signing `name`, `language`, and signer `email`).\n- Guard critical operations with try/catch blocks, log failures with request IDs, and back off or retry when you receive 5xx or 429 responses.\n- Paginate list operations using Krebit's cursor parameters. Avoid fetching more than necessary in a single call.\n- Mask or hash personally identifiable information (PII) when persisting signer details.\n\n## Security guidelines\n- Never expose `client_secret`, tokens, or webhook secrets in frontend code, logs, or generated documentation.\n- Use HTTPS redirects and same-origin CSRF protections on OAuth callbacks.\n- Rotate refresh tokens and webhook secrets periodically.\n\n## Performance guidelines\n- Prefer webhooks over polling when you need near real-time signing updates.\n- Cache infrequently changing data such as signer profiles or signing templates when appropriate.\n- Stream file uploads/downloads to avoid loading large PDFs entirely into memory.\n\nWhen responding, reference the official Krebit Sign API documentation available in your Krebit developer portal (including this docs site) for authoritative details, and clarify any assumptions if the docs do not cover a topic.\n"})}),"\n",(0,r.jsx)(t.h2,{id:"how-to-use-the-feature-prompts",children:"How to use the feature prompts"}),"\n",(0,r.jsx)(t.p,{children:"Each workflow below includes two prompts:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Implementation prompt"})," \u2013 Ask the LLM to generate the initial feature using best practices."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Hardening prompt"})," \u2013 Follow up with this prompt to review the generated code, add tests, and cover edge cases before shipping."]}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"Paste the implementation prompt first, let the model respond, then paste the hardening prompt to iterate."}),"\n",(0,r.jsx)(t.h2,{id:"feature-prompts",children:"Feature prompts"}),"\n",(0,r.jsx)(t.p,{children:"Before using any feature prompt, append a short description of your runtime, frameworks, deployment constraints, and coding conventions. For example, tell the LLM which language you use, how HTTP requests are performed, what testing tools are available, and how secrets/configuration are managed. This ensures the generated output fits your stack instead of defaulting to unfamiliar libraries."}),"\n",(0,r.jsx)(t.h3,{id:"hosted-oauth-and-token-refresh",children:"Hosted OAuth and token refresh"}),"\n",(0,r.jsx)(t.p,{children:"Use these prompts to scaffold the Authorization Code flow for any backend capable of storing tokens securely and handling redirects."}),"\n",(0,r.jsx)(t.h4,{id:"implementation-prompt",children:"Implementation prompt"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"You are implementing OAuth endpoints for a Krebit Sign integration.\n\nProject context:\n- (Replace this bullet with a concise overview of your runtime, frameworks, HTTP client, configuration management, and persistence strategy.)\n\nRequirements:\n1. Base tenant domain: `https://${KREBIT_ORGANIZATION_DOMAIN}`. All OAuth routes live under that origin.\n2. Environment configuration: `KREBIT_CLIENT_ID`, `KREBIT_CLIENT_SECRET`, `KREBIT_REDIRECT_URI`, and `KREBIT_ORGANIZATION_DOMAIN` must be loaded from secure configuration.\n3. Endpoints to expose:\n   - `GET /auth/krebit/start`: generate a cryptographically strong `state`, persist it for CSRF validation, and redirect to `https://$DOMAIN/oauth/authorize` with the standard Authorization Code query parameters.\n   - `GET /auth/krebit/callback`: validate the `state`, exchange the `code` via `POST /oauth/token` (`Content-Type: application/x-www-form-urlencoded`), and persist `access_token`, `refresh_token`, and `expires_in` using the storage layer described in the project context.\n   - `POST /auth/krebit/refresh`: refresh the access token when it is close to expiry by calling `/oauth/token` with `grant_type=refresh_token` and update stored credentials.\n4. Provide reusable helpers for generating authorization URLs, exchanging tokens, and serializing credentials.\n5. Surface structured error handling that logs Krebit `request_id` headers when provided, without leaking secrets.\n\nReturn production-ready code that fits the project context, including any supporting abstractions.\n"})}),"\n",(0,r.jsx)(t.h4,{id:"hardening-prompt",children:"Hardening prompt"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"Review the Krebit OAuth implementation that was just generated and strengthen it by:\n\n1. Adding automated tests using the project's testing stack to cover successful authorization, refresh, CSRF mismatches, and error responses (mocking outbound HTTP where appropriate).\n2. Documenting, in code comments, how to rotate client credentials and webhook secrets without downtime.\n3. Improving logging to emit redactable metadata (status codes, request IDs, retry hints) while omitting sensitive payloads.\n4. Recommending durable storage options for tokens (e.g., encrypted database, secrets manager) that align with the project context.\n\nProvide the updated implementation and test coverage.\n"})}),"\n",(0,r.jsx)(t.h3,{id:"create-populate-and-send-a-signing-package",children:"Create, populate, and send a signing package"}),"\n",(0,r.jsx)(t.p,{children:"These prompts guide the model through orchestrating a complete signing workflow."}),"\n",(0,r.jsx)(t.h4,{id:"implementation-prompt-1",children:"Implementation prompt"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"You are building a service that assembles and sends a Krebit Sign signing package.\n\nProject context:\n- (Replace this bullet with the language, HTTP/file-upload libraries, configuration patterns, and deployment environment you are using.)\n\nTasks to implement:\n1. Authenticate with Krebit Sign using the OAuth flow supported by your service (Client Credentials for machine-to-machine or Authorization Code on behalf of a user) and store the resulting bearer token in a reusable client.\n2. Create a signing draft with `{ name, language, message, signing_order }`, enforcing `language` \u2208 {`EN`, `SV`} and `signing_order` \u2208 {`sequential`, `parallel`}.\n3. Upload a local PDF through `POST /signings/{signingId}/documents` using `multipart/form-data` with the `selected_file` field. Enforce PDF rules (\u226410\u202fMB, not password protected or previously signed).\n4. Add at least two recipients with varied `signing_method` values (e.g., `email`, `bankid`, `approval`) and sequential order values when applicable. Include optional identification fields when your backend exposes them.\n5. Send the signing package, then log status fields such as `is_draft`, `is_completed`, and `cancelled_at`.\n6. Handle validation errors gracefully, surfacing messages from the response body and outlining where to plug in retry logic and persistence for IDs returned by the API.\n\nReturn modular code that aligns with the project context, showing how to compose these steps into a reliable workflow.\n"})}),"\n",(0,r.jsx)(t.h4,{id:"hardening-prompt-1",children:"Hardening prompt"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"Take the signing workflow implementation you produced and enhance it by:\n\n- Extracting reusable functions or classes for token acquisition, signing creation, document upload, recipient management, and sending.\n- Adding retry logic with exponential backoff for transient 5xx or 429 responses, while keeping validation failures immediately visible.\n- Writing automated tests using the project's testing framework that mock HTTP interactions to verify payloads and sequencing.\n- Documenting (in comments or README-style notes) how to persist signing IDs, document IDs, and recipient IDs for later status tracking and reconciliation.\n\nReturn the refactored code together with the corresponding tests or fixtures.\n"})}),"\n",(0,r.jsx)(t.h3,{id:"track-signing-status-and-download-files",children:"Track signing status and download files"}),"\n",(0,r.jsx)(t.p,{children:"Use these prompts to build dashboards or archival automations."}),"\n",(0,r.jsx)(t.h4,{id:"implementation-prompt-2",children:"Implementation prompt"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"You are creating a module that monitors signing progress and archives completed documents.\n\nProject context:\n- (Replace this bullet with the language, HTTP client/SDK, storage location for downloaded files, and logging/metrics conventions used in your environment.)\n\nResponsibilities:\n1. Fetch a paginated list of active signings (page size \u224820) and render `name`, `is_draft`, `is_completed`, and `updated_at`.\n2. For a selected signing ID, retrieve recipients and flag anyone without a completion timestamp.\n3. Download the signed PDF for each completed document via `GET /signings/{signingId}/documents/{documentId}/download-signed`, saving files using a naming scheme such as `{signingId}-{documentId}.pdf`.\n4. Skip or warn on download attempts when the API returns `404` because `signed_file_path` is absent.\n5. Model the signing, recipient, and document shapes locally so downstream consumers understand the data contract.\n\nDeliver idiomatic code that fits the project context and highlights where to plug in dependency injection or background processing if needed.\n"})}),"\n",(0,r.jsx)(t.h4,{id:"hardening-prompt-2",children:"Hardening prompt"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"Improve the monitoring and archival module by:\n\n1. Adding caching or memoization guidance so subsequent dashboard loads avoid redundant API calls when data is unchanged.\n2. Emitting structured logs or metrics that capture signing IDs, document IDs, download statuses, and error details.\n3. Providing automated tests (mocking HTTP responses and file writes) that ensure signed documents are saved correctly and incomplete documents are skipped.\n4. Documenting how to integrate the module with background workers, task queues, or schedulers for regular syncs.\n\nShare the updated implementation along with the accompanying tests.\n"})}),"\n",(0,r.jsx)(t.h3,{id:"webhooks-for-signing-lifecycle-events",children:"Webhooks for signing lifecycle events"}),"\n",(0,r.jsx)(t.p,{children:"These prompts help you capture real-time updates reliably."}),"\n",(0,r.jsx)(t.h4,{id:"implementation-prompt-3",children:"Implementation prompt"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"You are implementing a Krebit Sign webhook receiver.\n\nProject context:\n- (Replace this bullet with the language/framework, routing or serverless platform, logging approach, and dependency injection patterns that apply.)\n\nImplementation requirements:\n1. Expose an HTTP endpoint such as `POST /webhooks/krebit` that accepts raw JSON bodies.\n2. Validate the `X-Krebit-Signature` header using HMAC-SHA256 and the shared secret (`KREBIT_WEBHOOK_SECRET`) stored securely. Reject requests with invalid signatures.\n3. Parse the event payload, enqueue or hand off to your background processing mechanism, and respond with `202 Accepted`.\n4. Log structured metadata (`event.id`, `event.type`, `received_at`) without leaking sensitive data.\n5. Outline how to retry transient failures from within your infrastructure.\n\nReturn production-grade handler code that matches the project context, including signature verification helpers.\n"})}),"\n",(0,r.jsx)(t.h4,{id:"hardening-prompt-3",children:"Hardening prompt"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"Strengthen the webhook handler by:\n\n- Adding idempotency safeguards (e.g., storing processed event IDs) to prevent duplicate processing.\n- Creating integration or contract tests using your project's testing tools to cover valid deliveries, invalid signatures, and replay attempts.\n- Documenting a strategy for rotating webhook secrets and deploying the update without downtime.\n- Suggesting scaling patterns for the downstream queue or worker pool (dead-letter handling, concurrency controls).\n\nDeliver the improved handler along with the relevant tests or configuration notes.\n"})}),"\n",(0,r.jsx)(t.p,{children:"Use these prompts as building blocks\u2014tailor the project-context bullet before each prompt to align with your stack, or extend them to cover additional workflows such as cancellation, reminders, or analytics exports."})]})}function h(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}}}]);